<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>kubernetes on // √Ålex Go{,5z}</title><link>https://agonzalezro.github.io/tags/kubernetes/</link><description>Recent content in kubernetes on // √Ålex Go{,5z}</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 16 Apr 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://agonzalezro.github.io/tags/kubernetes/index.xml" rel="self" type="application/rss+xml"/><item><title>How to prepare the Certified Kubernetes Administrator exam</title><link>https://agonzalezro.github.io/posts/cka/</link><pubDate>Mon, 16 Apr 2018 00:00:00 +0000</pubDate><guid>https://agonzalezro.github.io/posts/cka/</guid><description>
&lt;p>Finally last weekend I did the CKA exam, I was procrastinating it a bit in part because I didn&amp;rsquo;t know what to expect since Kubernetes is huge and I thought that each day extra I spend reading about it would help me.&lt;/p>
&lt;p>TLDR; I did pass the exam and if you work daily with Kubernetes or variants as Openshift you will be ok, they are not trying to catch you in some weird question that not even &lt;a href="https://twitter.com/kelseyhightower">Kelsey&lt;/a> would know how to answer üòÄ&lt;/p>
&lt;p>&lt;img src="https://agonzalezro.github.io/devops/cka.png" alt="CKA certification">&lt;/p>
&lt;h2 id="preparation">Preparation&lt;/h2>
&lt;p>Giving the long quantity of topics that could be covered in the exam I have used several resources to study it.
I will try to sort this in a way that makes sense if you have no knowledge about Kubernetes at all, if you are already familiarized with it you probably can skip some of the links.&lt;/p>
&lt;p>First of all you will need to know the basic Kubernetes resources, if you are a video fan maybe this video could help you: &lt;a href="https://www.youtube.com/embed/K_Kh4LMiiqQ">&amp;ldquo;From pets to cattle, the way of Kubernetes&amp;rdquo;&lt;/a> (no spam üò¨) but after watching it you will need to get more in depth, for doing so I recommend the book &lt;a href="http://shop.oreilly.com/product/0636920043874.do">&amp;ldquo;Kubernetes: Up and Running&amp;rdquo;&lt;/a>.&lt;/p>
&lt;p>Now that you know the basics probably you will want to test it, you have several ways for doing it: minikube, creating a cluster in GKE, etc&amp;hellip; but if you don&amp;rsquo;t want to bother about it yet, use &lt;a href="https://www.katacoda.com/">Katacoda&lt;/a> and try to finish some of the free Scenarios they have there.&lt;/p>
&lt;p>You are almost there but if you are missing troubleshooting experience because you never administrated a Kubernetes cluster take a look to: &lt;a href="http://shop.oreilly.com/product/0636920064947.do">&amp;ldquo;Kubernetes Cookbook&amp;rdquo;&lt;/a>; this book is pretty focused on pragmatic problems, it will definitely help you in case you need to troubleshoot stuff and try to follow &lt;a href="https://github.com/kelseyhightower/kubernetes-the-hard-way">&amp;ldquo;Kubernetes the hard way&amp;rdquo;&lt;/a> that would help you a lot to understand how to install or fix the Kubernetes components.&lt;/p>
&lt;p>If have read all the previous links but you still want more, take a look to the official documentation at &lt;a href="https://kubernetes.io/">kubernetes.io&lt;/a> to review all the concepts.&lt;/p>
&lt;h2 id="the-day-of-the-exam">The day of the exam&lt;/h2>
&lt;p>Part of my anxiety regarding the exam was that I didn&amp;rsquo;t know what to expect after sitting in my PC at 3pm, what would happen if my browser gets blocked? If I can&amp;rsquo;t understand a question? If I break my cluster? What&amp;rsquo;s going to be my &amp;ldquo;IDE&amp;rdquo;?
I think some of these questions could be easily answered by the Linux Foundation in form of a video explaining how to do the exam, but I couldn&amp;rsquo;t find anything similar so I will try to help you here:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Before the exam, the examiner will ask you yo &lt;strong>clean your desk and drawers&lt;/strong>, completely, I had some books in drawers that were not covered by the cam and I had to move them. I also had an schedule in a wall and I had to unglue it.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The &lt;strong>place should be quiet&lt;/strong> because even if you usually work with headphones you will not be allowed to use them.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The examiner will ask you to see all the room, even under the desk.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The &lt;strong>examiner will not talk to you by voice, only by chat&lt;/strong>. He/she will hear you because you will need to share the screen and micro. When you do that he will ask you to show open processes et al to be sure you are not copying. I found this a little bit excessive, but&amp;hellip; rules and probably some previous cheaters (shame on you!).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The exam happens in a Chrome tab, the left side will show you the questions and the percentage it covers and you will be able to jump from one to another. All the questions are atomic. The right side is for the shell, I tried to use tmux there, but it was pretty difficult inside a browser terminal. You can also have a popup with notes.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>After running a command in the shell it got blocked and I panicked, I went to my Inbox to write an email to support but luckily after few second (maybe a minute or two but it looked like a long time to me) it went back. I let the examiner know just in case he/she saw me in the email, and that&amp;rsquo;s it.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>You can &lt;strong>only open a tab with kubernetes.io&lt;/strong> and use its search box, no Google. In the past it seems it wasn&amp;rsquo;t like this. It&amp;rsquo;s ok because the answer is usually there, but you need to get used to it, maybe try it out during the preparation.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>It&amp;rsquo;s ok to request a pause&lt;/strong>, but careful because the time doesn&amp;rsquo;t stop.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>You have three hours to finish the exam, &lt;strong>if you get blocked it‚Äôs better to skip&lt;/strong> that question for now and retake it later.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="the-wait">The wait&lt;/h2>
&lt;p>I did the exam last Saturday afternoon, from 3pm to 6pm and when I work up this morning I already had the result in my Inbox so you will not need to wait a lot for it, probably during work days it&amp;rsquo;s going to be even quicker.&lt;/p>
&lt;p>&lt;img src="https://agonzalezro.github.io/devops/thatsall.jpg" alt="that&amp;rsquo;s all folks">&lt;/p>
&lt;p>So, that&amp;rsquo;s it from me.
If you are interested in Kubernetes and you work with it often you will not have any trouble passing the exam, however, I understand that giving the huge range of things that they could ask you the exam can be intimidating, trust yourself and you will be ok!
If you do the exam and this helps you somehow or you just want to let me know anything, &lt;a href="https://twitter.com/agonzalezro">please ping me on @agonzalezro&lt;/a>!&lt;/p></description></item><item><title>Closing 2016, a list of talks I gave</title><link>https://agonzalezro.github.io/posts/2016/</link><pubDate>Sun, 29 Jan 2017 00:00:00 +0000</pubDate><guid>https://agonzalezro.github.io/posts/2016/</guid><description>
&lt;figure class="left" >
&lt;img src="https://agonzalezro.github.io/rafa.jpg" alt="A cow" />
&lt;figcaption class="center" >Thanks @rais38 for the photo!&lt;/figcaption>
&lt;/figure>
&lt;p>We are almost at the end of January but I didn&amp;rsquo;t want to end the first month of the year without doing a small recap of the talks I gave last year.&lt;/p>
&lt;p>When I moved to Spain at the end of 2015 I said to myself that I didn&amp;rsquo;t want to forget the little English I knew so I needed to force myself to keep traveling outside of Spain and to do some public speaking. The public speaking bit is for two reason: keep forcing myself to speak English and&amp;hellip; to lose my fear about talking English in front of a bunch of people you don&amp;rsquo;t know about a tech that they probably know better than you.&lt;/p>
&lt;p>I could do it much better than I did, but I am happy with the results.&lt;/p>
&lt;h2 id="my-english-talks">My English talks&lt;/h2>
&lt;h3 id="custom-volume-plugins--kubeconhttpskubeconio">Custom Volume Plugins @ &lt;a href="https://kubecon.io">Kubecon&lt;/a>&lt;/h3>
&lt;p>&lt;em>&lt;a href="https://www.youtube.com/watch?v=33VzHXuuRs4">Video&lt;/a> &amp;amp; &lt;a href="https://speakerdeck.com/agonzalezro/custom-volume-plugins">slides&lt;/a>&lt;/em>&lt;/p>
&lt;p>I prepared this talk a lot, but I was pretty nervous on stage I did a terrible job. Some people said that they learn a lot of new concepts, but they were just trying to be friendly :) Probably I underestimated the pressure behind a Kubecon talk and I will fix this in the future.&lt;/p>
&lt;h3 id="python-kubernetes-and-friends--pygrunnhttpwwwpygrunnorg">Python, Kubernetes and friends @ &lt;a href="http://www.pygrunn.org/">PyGrunn&lt;/a>&lt;/h3>
&lt;p>&lt;em>&lt;a href="https://www.youtube.com/watch?v=0tsaMVoydDg">Video&lt;/a> &amp;amp; &lt;a href="https://speakerdeck.com/agonzalezro/python-kubernetes-and-friends">Slides&lt;/a>&lt;/em>&lt;/p>
&lt;p>I gave this in the best (IMHO, but I could be biased) Python conference in the Netherlands, it went pretty well, I knew the things I did pretty badly in my previous talk at Kubeconf and I tried to fix the problems. However, if you check the video and you can give me some advice, feel free.&lt;/p>
&lt;h3 id="from-pets-to-cattle-the-way-of-kubernetes">From pets to cattle, the way of Kubernetes&lt;/h3>
&lt;p>&lt;em>&lt;a href="https://www.youtube.com/watch?v=K_Kh4LMiiqQ">Video&lt;/a> &amp;amp; &lt;a href="https://speakerdeck.com/agonzalezro/from-pets-to-cattle-the-way-of-kubernetes">Slides&lt;/a>&lt;/em>&lt;/p>
&lt;p>This talk was in Spain, but since it was a big conference I gave it in English for non-Spanish speakers. I think the talk was ok, I got a 4 out 5 in their feedback tool, but it seems I didn&amp;rsquo;t attach the people because nobody asking anything at the end. Out of camera I got several questions tho.&lt;/p>
&lt;h2 id="and-the-spanish-ones">And the Spanish ones&lt;/h2>
&lt;p>All these talks were internal Jobandtalent talks for my ex-colleagues, I hope it helped them, they definitely helped me, it was a trusty environment and the questions were really interesting. You probably wouldn&amp;rsquo;t ask that much in a conference but it helps the speaker (in this case me) to improve.&lt;/p>
&lt;h3 id="go-101--jobandtalenthttpwwwjobandtalentcom">Go 101 @ &lt;a href="http://www.jobandtalent.com/">Jobandtalent&lt;/a>&lt;/h3>
&lt;p>&lt;em>&lt;a href="https://www.youtube.com/watch?v=zaywpuLV4BY">Video&lt;/a> &amp;amp; &lt;a href="https://speakerdeck.com/agonzalezro/go-101-updated">Slides&lt;/a>&lt;/em>&lt;/p>
&lt;h3 id="kubernetes-101--jobandtalenthttpwwwjobandtalentcom">Kubernetes 101 @ &lt;a href="http://www.jobandtalent.com/">Jobandtalent&lt;/a>&lt;/h3>
&lt;p>&lt;em>&lt;a href="https://www.youtube.com/watch?v=5YmhMM_q4uI">Video&lt;/a> &amp;amp; &lt;a href="https://speakerdeck.com/agonzalezro/kubernetes-101">Slides&lt;/a>&lt;/em>&lt;/p>
&lt;h3 id="docker-101--jobandtalenthttpwwwjobandtalentcom">Docker 101 @ &lt;a href="http://www.jobandtalent.com/">Jobandtalent&lt;/a>&lt;/h3>
&lt;p>&lt;em>&lt;a href="https://speakerdeck.com/agonzalezro/docker-101">Slides&lt;/a>&lt;/em>&lt;/p>
&lt;p>Out of that list I gave some other, for example, about &lt;a href="https://github.com/agonzalezro/goqui/blob/master/examples/neo4j_intro_slides.neo4j">Neo4J&lt;/a> and a workshop with my friend &lt;a href="https://twitter.com/ipedrazas">@ipedrazas&lt;/a> about Kubernetes &amp;amp; Docker, here, in Spain. Also, I started &lt;a href="https://meetup.com/mad-scalability">mad Scalability&lt;/a> and I am quite happy with about it!&lt;/p>
&lt;p>I will try to prepare some CFP in 2017, but as today I see it pretty difficult because of reasons :)&lt;/p>
&lt;p>As I said at the beginning of the post, one of the reasons why I tried to do public speaking is to improve at it, you if you have any advice &lt;a href="https://twitter.com/agonzalezro">share it with me&lt;/a> please!&lt;/p></description></item><item><title>Scheduling Your Kubernetes Pods With Elixir</title><link>https://agonzalezro.github.io/posts/elixir-scheduler/</link><pubDate>Mon, 16 Jan 2017 00:00:00 +0000</pubDate><guid>https://agonzalezro.github.io/posts/elixir-scheduler/</guid><description>
&lt;blockquote>
&lt;p>This was originally posted on &lt;a href="https://deis.com/blog/2016/scheduling-your-kubernetes-pods-with-elixir/">deis.com&lt;/a>.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a href="https://twitter.com/kelseyhightower">Kelsey Hightower&lt;/a> gave a really interesting talk at &lt;a href="https://skillsmatter.com/conferences/7208-containersched-2015">ContainerSched&lt;/a> about how to create your own scheduler using the Kubernetes HTTP API.&lt;/p>
&lt;p>The talk was awesome. It&amp;rsquo;s incredible to see what kind of things you can do with a base system as good as Kubernetes.&lt;/p>
&lt;p>However, I missed one thing. The &lt;a href="https://github.com/kelseyhightower/scheduler">example&lt;/a> provided by Kelsey was a Go application. Which is the main language used with Kubernetes. So, if you look at that code without any context, you might think it&amp;rsquo;s using some kind of Kubernetes internal packages. But it&amp;rsquo;s not! It&amp;rsquo;s a standalone piece of code that happens to make some HTTP calls.&lt;/p>
&lt;p>To illustrate this point, I decided to write my own scheduler, in a different language. In my case, &lt;a href="http://elixir-lang.org/">Elixir&lt;/a>, because that&amp;rsquo;s the language I happen to be learning at the moment.&lt;/p>
&lt;p>This post isn&amp;rsquo;t an intro to Elixir, but the code should be easy to follow.&lt;/p>
&lt;p>Also, I&amp;rsquo;m going to use &lt;code>localhost&lt;/code> when accessing the Kubernetes API. Why? For simplicity. If we run &lt;code>kubectl proxy&lt;/code> on a computer connected to the Kubernetes master, we will not need to deal with authorization, hosts, and so on. The &lt;code>proxy&lt;/code> command will do it for us.&lt;/p>
&lt;p>So, let&amp;rsquo;s dive in.&lt;/p>
&lt;h2 id="get-a-list-of-unscheduled-jobs">Get a List of Unscheduled Jobs&lt;/h2>
&lt;p>To start off with, we need a pod for our scheduler to schedule.&lt;/p>
&lt;p>By default, Kubernetes will schedule all your pods. So, we need to create a unscheduled pod and we need to indicate to Kubernetes that we don&amp;rsquo;t want our pod to get scheduled.&lt;/p>
&lt;p>So, create a file called &lt;code>pod.yml&lt;/code> and put this inside:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="color:#f92672">apiVersion&lt;/span>: &lt;span style="color:#ae81ff">v1&lt;/span>
&lt;span style="color:#f92672">kind&lt;/span>: &lt;span style="color:#ae81ff">Pod&lt;/span>
&lt;span style="color:#f92672">metadata&lt;/span>:
&lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">custom&lt;/span>
&lt;span style="color:#f92672">annotations&lt;/span>:
&lt;span style="color:#f92672">scheduler.alpha.kubernetes.io/name&lt;/span>: &lt;span style="color:#ae81ff">myOwnScheduler&lt;/span>
&lt;span style="color:#f92672">spec&lt;/span>:
&lt;span style="color:#f92672">containers&lt;/span>:
- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;nginx&amp;#34;&lt;/span>
&lt;span style="color:#f92672">image&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;nginx:1.10.0&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Notice the &lt;code>scheduler.alpha.kubernetes.io/name&lt;/code> annotation we use to specify that our scheduler (that we call &lt;code>myOwnScheduler&lt;/code>) will be handling this pod.&lt;/p>
&lt;p>Now, let&amp;rsquo;s create the pod from the definition file:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">kubectl create -f pod.yml
&lt;/code>&lt;/pre>&lt;/div>&lt;p>After you&amp;rsquo;ve done this, there will be an unscheduled job waiting for us inside Kubernetes. Why unscheduled? Because our pod says it wants to be scheduled by the &lt;code>myOwnScheduler&lt;/code> scheduler, but we&amp;rsquo;ve not created it yet, so Kubernetes can&amp;rsquo;t schedule it.&lt;/p>
&lt;p>So, let&amp;rsquo;s build our scheduler.&lt;/p>
&lt;p>First, our scheduler must be able to grab this unscheduled job from the API.&lt;/p>
&lt;p>Here&amp;rsquo;s the function I wrote to do that:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-elixir" data-lang="elixir">&lt;span style="color:#66d9ef">def&lt;/span> unscheduled_pods &lt;span style="color:#66d9ef">do&lt;/span>
is_managed_by_us &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>(get_in(&amp;amp;1, [&lt;span style="color:#e6db74">&amp;#34;metadata&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;annotations&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;scheduler.alpha.kubernetes.io/name&amp;#34;&lt;/span>]) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#a6e22e">@name&lt;/span>)
resp &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">HTTPoison&lt;/span>&lt;span style="color:#f92672">.&lt;/span>get! &lt;span style="color:#e6db74">&amp;#34;http://127.0.0.1:8001/api/v1/pods?fieldSelector=spec.nodeName=&amp;#34;&lt;/span>
resp&lt;span style="color:#f92672">.&lt;/span>body
&lt;span style="color:#f92672">|&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">Poison&lt;/span>&lt;span style="color:#f92672">.&lt;/span>decode!
&lt;span style="color:#f92672">|&amp;gt;&lt;/span> get_in([&lt;span style="color:#e6db74">&amp;#34;items&amp;#34;&lt;/span>])
&lt;span style="color:#f92672">|&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">Enum&lt;/span>&lt;span style="color:#f92672">.&lt;/span>filter(is_managed_by_us)
&lt;span style="color:#f92672">|&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">Enum&lt;/span>&lt;span style="color:#f92672">.&lt;/span>map(&lt;span style="color:#f92672">&amp;amp;&lt;/span>(get_in(&amp;amp;1, [&lt;span style="color:#e6db74">&amp;#34;metadata&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>])))
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>As you can see we are using &lt;code>127.0.0.1&lt;/code> to query our API, this is posible thanks to the &lt;code>kubectl proxy&lt;/code> command we mentioned in the intro.&lt;/p>
&lt;p>This code grabs the name of all the pods that are waiting to be scheduled inside Kubernetes. It then uses the &lt;code>is_managed_by_us&lt;/code> function to see whether the &lt;code>@name&lt;/code> attribute is set to &lt;code>myOwnScheduler&lt;/code>. If this is true, the pod has indicated that it should be managed by our scheduler.&lt;/p>
&lt;h2 id="an-elixir-introduction">An Elixir Introduction&lt;/h2>
&lt;p>I said I wouldn&amp;rsquo;t explain Elixir, but I will just comment on three piece of syntax.&lt;/p>
&lt;p>The &lt;code>|&amp;gt;&lt;/code> in the code above is a pipe, like the &lt;code>|&lt;/code> character from a shell script. Using this passes the result from the left side as a parameter to the function on the right side. In this way return values can be piped through functions.&lt;/p>
&lt;p>The &lt;code>&amp;amp;&lt;/code> character marks an &lt;a href="https://en.wikipedia.org/wiki/Anonymous_function">anonymous function&lt;/a>, i.e. a function that we define inline as an expression. And &lt;code>&amp;amp;1&lt;/code> refers the first parameter received by the function.&lt;/p>
&lt;p>We can also use an anonymous function as parameter to another function. As we are doing, in the &lt;code>map&lt;/code> call.&lt;/p>
&lt;h2 id="get-a-list-of-available-nodes">Get a List of Available Nodes&lt;/h2>
&lt;p>Our &lt;code>unscheduled_pods&lt;/code> function gets us a list of pods that have not been scheduled yet. So next up, we can bind them to our nodes. That is, we tell our containers to run on particular nodes.&lt;/p>
&lt;p>But wait, how do we know what nodes are available?&lt;/p>
&lt;p>We&amp;rsquo;ll need to grab those as well, like this:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-elixir" data-lang="elixir">&lt;span style="color:#66d9ef">def&lt;/span> nodes &lt;span style="color:#66d9ef">do&lt;/span>
resp &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">HTTPoison&lt;/span>&lt;span style="color:#f92672">.&lt;/span>get! &lt;span style="color:#e6db74">&amp;#34;http://127.0.0.1:8001/api/v1/nodes&amp;#34;&lt;/span>
resp&lt;span style="color:#f92672">.&lt;/span>body
&lt;span style="color:#f92672">|&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">Poison&lt;/span>&lt;span style="color:#f92672">.&lt;/span>decode!
&lt;span style="color:#f92672">|&amp;gt;&lt;/span> get_in([&lt;span style="color:#e6db74">&amp;#34;items&amp;#34;&lt;/span>])
&lt;span style="color:#f92672">|&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">Enum&lt;/span>&lt;span style="color:#f92672">.&lt;/span>map(&lt;span style="color:#f92672">&amp;amp;&lt;/span>(get_in(&amp;amp;1, [&lt;span style="color:#e6db74">&amp;#34;metadata&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>])))
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>This code will return a list of all nodes.&lt;/p>
&lt;p>We could potentially request a lot more information from the API at this point, but for what we&amp;rsquo;re building, it&amp;rsquo;s not necessary. If you want to now what extra information is available, &lt;a href="http://kubernetes.io/kubernetes/third_party/swagger-ui/#!/api%2Fv1/listNamespacedNode">check the documentation for this endpoint&lt;/a>.&lt;/p>
&lt;h2 id="the-bind-function">The Bind Function&lt;/h2>
&lt;p>So let&amp;rsquo;s review.&lt;/p>
&lt;p>We have a list of all the unscheduled jobs that we are supposed to manage. And we have a list of all the nodes we can schedule jobs to.&lt;/p>
&lt;p>But how do we actually schedule a pods on a node?&lt;/p>
&lt;p>We call the bind endpoint, like this:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-elixir" data-lang="elixir">&lt;span style="color:#66d9ef">def&lt;/span> bind(pod_name, node_name) &lt;span style="color:#66d9ef">do&lt;/span>
url &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;http://127.0.0.1:8001/api/v1/namespaces/default/pods/&lt;/span>&lt;span style="color:#e6db74">#{&lt;/span>pod&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">/binding&amp;#34;&lt;/span>
payload &lt;span style="color:#f92672">=&lt;/span> %{
&lt;span style="color:#e6db74">&amp;#34;apiVersion&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;v1&amp;#34;&lt;/span>,
&lt;span style="color:#e6db74">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Binding&amp;#34;&lt;/span>,
&lt;span style="color:#e6db74">&amp;#34;metadata&amp;#34;&lt;/span>: %{
&lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>: pod_name,
},
&lt;span style="color:#e6db74">&amp;#34;target&amp;#34;&lt;/span>: %{
&lt;span style="color:#e6db74">&amp;#34;apiVersion&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;v1&amp;#34;&lt;/span>,
&lt;span style="color:#e6db74">&amp;#34;kind&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Node&amp;#34;&lt;/span>,
&lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>: node_name,
}
}
headers &lt;span style="color:#f92672">=&lt;/span> [{&lt;span style="color:#e6db74">&amp;#39;content-type&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;application/json&amp;#39;&lt;/span>}]
&lt;span style="color:#a6e22e">HTTPoison&lt;/span>&lt;span style="color:#f92672">.&lt;/span>post! url, payload &lt;span style="color:#f92672">|&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">Poison&lt;/span>&lt;span style="color:#f92672">.&lt;/span>encode!, headers
&lt;span style="color:#a6e22e">IO&lt;/span>&lt;span style="color:#f92672">.&lt;/span>puts &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">#{&lt;/span>pod_name&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> pod scheduled in &lt;/span>&lt;span style="color:#e6db74">#{&lt;/span>node_name&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>But before we can use this function, we need a scheduling strategy.&lt;/p>
&lt;h2 id="scheduling-strategy">Scheduling Strategy&lt;/h2>
&lt;p>For our simple scheduler, we will go with a random scheduling strategy.&lt;/p>
&lt;p>In effect, we schedule each pod on a random node. Multiple pods might even end up on the same node.&lt;/p>
&lt;p>Here&amp;rsquo;s how we do that:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-elixir" data-lang="elixir">&lt;span style="color:#66d9ef">def&lt;/span> schedule(pods) &lt;span style="color:#66d9ef">do&lt;/span>
pods
&lt;span style="color:#f92672">|&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">Enum&lt;/span>&lt;span style="color:#f92672">.&lt;/span>each(&lt;span style="color:#f92672">&amp;amp;&lt;/span>(bind(&amp;amp;1, &lt;span style="color:#a6e22e">Enum&lt;/span>&lt;span style="color:#f92672">.&lt;/span>random(nodes))))
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Of course, this is very basic, and there are much better ways to maximise the resources we have available to us. But we&amp;rsquo;re building this as a learning exercise. Feel free to extend this code if you want to take things further.&lt;/p>
&lt;p>Some ideas to get you going:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Round-robin_scheduling">Round-robin&lt;/a> pod scheduling.&lt;/li>
&lt;li>Implement your own version of Kubernete&amp;rsquo;s load-aware scheduling.&lt;/li>
&lt;li>Annotate the pods with some extra information, for example: cluster.type: raspberry if you want to send them to the Raspberry Pi nodes in your cluster.&lt;/li>
&lt;li>You could use some external source of truth, e.g. Nagios, to determine which nodes to schedule jobs on.&lt;/li>
&lt;/ul>
&lt;h2 id="putting-everything-together">Putting Everything Together&lt;/h2>
&lt;p>Now we have everything in place, a &lt;code>main&lt;/code> function is all that&amp;rsquo;s needed:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-elixir" data-lang="elixir">&lt;span style="color:#66d9ef">def&lt;/span> main(_args) &lt;span style="color:#66d9ef">do&lt;/span>
unscheduled_pods
&lt;span style="color:#f92672">|&amp;gt;&lt;/span> schedule
&lt;span style="color:#66d9ef">end&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now you are able to run your program!&lt;/p>
&lt;p>A simple &lt;code>elixir your_script.exs&lt;/code> should do it, if you have all the dependencies. But you probably don&amp;rsquo;t, so I recommend you follow the Usage section in &lt;a href="https://github.com/agonzalezro/escheduler#usage">the README&lt;/a> for the code that accompanies this post.&lt;/p>
&lt;h2 id="wrap-up">Wrap Up&lt;/h2>
&lt;p>For a most things, you probably don&amp;rsquo;t want to write your own scheduler. The one provided by Kubernetes is good for so many things.&lt;/p>
&lt;p>But if you want to do something the default Kubernetes scheduler can&amp;rsquo;t do, it&amp;rsquo;s not as difficult as you might think to write your own and slot it in, and continue to take advantage of everything Kubernetes has to offer.&lt;/p>
&lt;p>I&amp;rsquo;ve put my code up for &lt;a href="https://github.com/agonzalezro/escheduler">my Elixir scheduler&lt;/a>, on GitHub in case you want to check it out. This repository has everything you need to follow along with this post, from the YAML pod definition to the scheduler itself.&lt;/p></description></item><item><title>Using Kong with Kubernetes</title><link>https://agonzalezro.github.io/posts/kong-k8s/</link><pubDate>Thu, 17 Dec 2015 00:00:00 +0000</pubDate><guid>https://agonzalezro.github.io/posts/kong-k8s/</guid><description>
&lt;blockquote>
&lt;p>This was originally posted on &lt;a href="http://k8s.uk/using-kong-with-kubernetes.html">k8s.uk&lt;/a>.&lt;/p>
&lt;/blockquote>
&lt;p>If you don&amp;rsquo;t know about &lt;a href="https://getkong.org">Kong&lt;/a> yet, you should take a look. It&amp;rsquo;s an Open Source API Gateway, they define themselves as: &amp;ldquo;The open-source management layer for APIs, delivering high performance and reliability.&amp;rdquo; and they are quite right.&lt;/p>
&lt;p>I was playing with Kong lately at work (&lt;a href="http://jobandtalent.com">jobandtalent.com&lt;/a>, we are hiring!) and I think that it could be pretty awesome as a entry layer to your microservices platform running in Kubernetes.&lt;/p>
&lt;p>For the sake of simplicity I will not run Kong in Kubernetes, but it shouldn&amp;rsquo;t be so difficult since &lt;a href="https://getkong.org/install/">they already provide Docker images&lt;/a>. Also, running Kong on the same cluster you will be able to use internal networking between pods: win-win.&lt;/p>
&lt;p>So, what will I show?&lt;/p>
&lt;ul>
&lt;li>I will deploy a Kubernetes with 2 pods (our 2 microservices) &amp;amp;&lt;/li>
&lt;li>I will install Kong locally and configure it to point to this 2 services.&lt;/li>
&lt;/ul>
&lt;h2 id="go--packing">Go &amp;amp; packing&lt;/h2>
&lt;p>I&amp;rsquo;ve created a small Go app that will show the value of an environment variable when you &lt;code>GET /&lt;/code>:&lt;/p>
&lt;pre>&lt;code>package main
import (
&amp;quot;fmt&amp;quot;
&amp;quot;log&amp;quot;
&amp;quot;net/http&amp;quot;
&amp;quot;os&amp;quot;
)
func main() {
http.HandleFunc(&amp;quot;/&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
fmt.Fprintf(w, os.Getenv(&amp;quot;TEST_RESULT&amp;quot;))
})
log.Fatal(http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil))
}
&lt;/code>&lt;/pre>
&lt;p>Now we will build the application to later pack it in our image. Remember that if you are in Mac you will need to cross-compile the app to work on Linux:&lt;/p>
&lt;pre>&lt;code>$ GOOS=linux go build
&lt;/code>&lt;/pre>
&lt;p>We can pack it into our images now. For doing so we need a &lt;code>Dockerfile&lt;/code>. It&amp;rsquo;s a simple binary, so the &lt;code>Dockerfile&lt;/code> is not complex at all:&lt;/p>
&lt;pre>&lt;code>FROM scratch
ADD app /
ENTRYPOINT [&amp;quot;/app&amp;quot;]
&lt;/code>&lt;/pre>
&lt;p>Cool! What can we do now with our shiny image? Yes, you are right! Push it to the hub:&lt;/p>
&lt;pre>&lt;code>$ docker build -t agonzalezro/kong-test .
$ docker push agonzalezro/kong-test
&lt;/code>&lt;/pre>
&lt;h2 id="k8s">k8s&lt;/h2>
&lt;p>We have our image on the registry and all we need now is running it on Kubernetes. I am using &lt;a href="https://cloud.google.com/container-engine/">Google Container Engine&lt;/a> for deploying this, but you can use whatever you prefer.&lt;/p>
&lt;p>Let&amp;rsquo;s create our RCs &amp;amp; services:&lt;/p>
&lt;pre>&lt;code># rc1.yml
apiVersion: v1
kind: ReplicationController
metadata:
name: api1
spec:
selector:
name: api
version: first
template:
metadata:
labels:
name: api
version: first
spec:
containers:
- name: app
image: agonzalezro/kong-test
env:
- name: TEST_RESULT
value: &amp;quot;This is the first app&amp;quot;
# rc2.yml
apiVersion: v1
kind: ReplicationController
metadata:
name: api2
spec:
selector:
name: api
version: second
template:
metadata:
labels:
name: api
version: second
spec:
containers:
- name: app
image: agonzalezro/kong-test
env:
- name: TEST_RESULT
value: &amp;quot;Second!&amp;quot;
# svc1.yml
apiVersion: v1
kind: Service
metadata:
name: app1-svc
spec:
type: LoadBalancer
ports:
- port: 80
targetPort: 8080
selector:
name: api
version: first
# svc2.yml
apiVersion: v1
kind: Service
metadata:
name: app2-svc
spec:
type: LoadBalancer
ports:
- port: 80
targetPort: 8080
selector:
name: api
version: second
&lt;/code>&lt;/pre>
&lt;p>And now run it:&lt;/p>
&lt;pre>&lt;code>$ kubectl create -f rc1.yml -f rc2.yml -f svc1.yml -f svc2.yml
&lt;/code>&lt;/pre>
&lt;p>Wait for the service and the pods to be ready and check their IPS:&lt;/p>
&lt;pre>&lt;code>$ kubectl get services
NAME CLUSTER_IP EXTERNAL_IP PORT(S) SELECTOR AGE
app1-svc 10.159.242.86 130.211.89.175 80/TCP name=api,version=first 17m
app2-svc 10.159.246.93 104.155.53.175 80/TCP name=api,version=second 17m
kubernetes 10.159.240.1 &amp;lt;none&amp;gt; 443/TCP &amp;lt;none&amp;gt; 1h
&lt;/code>&lt;/pre>
&lt;h2 id="kong">Kong&lt;/h2>
&lt;p>Follow the instruction here: &lt;a href="https://getkong.org/install/docker/">https://getkong.org/install/docker/&lt;/a> to install Kong locally.&lt;/p>
&lt;p>Yeah! We have it up &amp;amp; running so let&amp;rsquo;s point it to our shinny cluster. We need to use Kong API for that (port &lt;code>:8001&lt;/code>):&lt;/p>
&lt;pre>&lt;code>$ http http://dockerhost:8001/apis/ name=first upstream_url=http://130.211.89.175 request_path=/first strip_request_path=true
$ http http://dockerhost:8001/apis/ name=second upstream_url=http://104.155.53.175 request_path=/second strip_request_path=true
&lt;/code>&lt;/pre>
&lt;p>What we did here? We set up two new endpoints &lt;code>/first&lt;/code> &amp;amp; &lt;code>/second&lt;/code> that are pointing to the both Kubernetes services previously created. We could have done it with DNS as well using &lt;code>request_host&lt;/code> instead.&lt;/p>
&lt;p>Lets call Kong on the port &lt;code>:8000&lt;/code> to use them:&lt;/p>
&lt;pre>&lt;code>$ http http://dockerhost:8000/first
HTTP/1.1 200 OK
Connection: keep-alive
Content-Length: 21
Content-Type: text/plain; charset=utf-8
Date: Thu, 17 Dec 2015 21:43:41 GMT
Via: kong/0.5.4
This is the first app
$ http http://dockerhost:8000/second
HTTP/1.1 200 OK
Connection: keep-alive
Content-Length: 7
Content-Type: text/plain; charset=utf-8
Date: Thu, 17 Dec 2015 21:43:44 GMT
Via: kong/0.5.4
Second!
&lt;/code>&lt;/pre>
&lt;p>\o/ We did it!&lt;/p>
&lt;h2 id="next-steps">Next steps&lt;/h2>
&lt;p>You have Kong pointed to your cluster, now it&amp;rsquo;s up to your imagination what to do next. I would say try to configure some rate limiting or auth, it&amp;rsquo;s deadly simply. Check them here: &lt;a href="https://getkong.org/plugins/">https://getkong.org/plugins/&lt;/a>&lt;/p>
&lt;p>If you have any question or you want to discuss this further let me know at &lt;a href="https://twitter.com/agonzalezro">@agonzalezro&lt;/a>.&lt;/p></description></item><item><title>Kubernetes volume plugins and Flocker</title><link>https://agonzalezro.github.io/posts/k8s_flocker_plugin/</link><pubDate>Tue, 20 Oct 2015 00:00:00 +0000</pubDate><guid>https://agonzalezro.github.io/posts/k8s_flocker_plugin/</guid><description>
&lt;p>Last month I was working with the guys from &lt;a href="http://www.jetstack.io/">Jetstack&lt;/a> &amp;amp; &lt;a href="https://clusterhq.com/">ClusterHQ&lt;/a> developing a plugina for Kubernetes that will allow the people to easily use &lt;a href="https://clusterhq.com/flocker/introduction/">Flocker&lt;/a> there.&lt;/p>
&lt;p>Yesterday I had the pleasure of sharing the stage with &lt;a href="https://twitter.com/Rimusz">Rimas Mocevicius&lt;/a>, &lt;a href="https://twitter.com/kelseyhightower">Kelsey Hightower&lt;/a> &amp;amp; &lt;a href="https://twitter.com/ipedrazas">Ivan Pedrazas&lt;/a> at the &lt;a href="http://www.meetup.com/Kubernetes-London/events/226026848/">Kubernetes London meetup&lt;/a> to present the plugin and show the audience that creating volume plugins for Kubernetes is easier than it looks at the first glance.&lt;/p>
&lt;p>As an introduction of what you will find:&lt;/p>
&lt;ol>
&lt;li>Introduction to Flocker&lt;/li>
&lt;li>Introduction to Kubernetes&lt;/li>
&lt;li>Introduction to the plugin itself&lt;/li>
&lt;li>Code&lt;/li>
&lt;li>Summary&lt;/li>
&lt;/ol>
&lt;p>Here they are:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Also, if you want to take a look to the presenter notes or the original slides, I have them in a GitHub repo: &lt;a href="https://github.com/agonzalezro/slides/tree/master/k8s_flocker_plugin">https://github.com/agonzalezro/slides/tree/master/k8s_flocker_plugin&lt;/a>&lt;/p>
&lt;p>Feel free to contact me if you have any questions! I am &lt;a href="https://twitter.com/agoznalezro">agonzalezro in twitter&lt;/a>.&lt;/p></description></item><item><title>How to deploy and update a python app using Kubernetes</title><link>https://agonzalezro.github.io/posts/oct_2015_djugl/</link><pubDate>Fri, 09 Oct 2015 00:00:00 +0000</pubDate><guid>https://agonzalezro.github.io/posts/oct_2015_djugl/</guid><description>
&lt;p>Two days ago I gave a small talk in the &lt;a href="https://twitter.com/DJUGL">DJUGL (Django User Group London)&lt;/a> explaining how we could deploy a test application into Kubernetes. This post is going to explain something pretty similar, how to deploy a Flask app into Kubernetes and how to rolling update it.&lt;/p>
&lt;p>Before starting, you can find all the materials of this post in my &lt;a href="https://github.com/agonzalezro/k8s-py-example">k8s-py-example&lt;/a> repo.&lt;/p>
&lt;p>Download the app and build it twice, one for each of the version that you want to deploy. This versions will need to be tagged properly and sent to &lt;a href="https://hub.docker.com/">Docker Hub&lt;/a>. Basically the steps to follow are:&lt;/p>
&lt;pre>&lt;code>docker build -t agonzalezro/k8s-py-example .
docker tag agonzalezro/k8s-py-example:latest agonzalezro/k8s-py-example:0.1
# Change the code (src/app.py) a little bit to see the differences
docker build -t agonzalezro/k8s-py-example .
docker tag agonzalezro/k8s-py-example:latest agonzalezro/k8s/py-example:0.2
docker push agonzalezro/k8s-py-example
&lt;/code>&lt;/pre>
&lt;p>Now that all the work related with Docker is done, let&amp;rsquo;s take a look to the needed k8s files:&lt;/p>
&lt;p>&lt;strong>rc-0.1.yml&lt;/strong>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;strong>rc-0.2.yml&lt;/strong>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;strong>service.yml&lt;/strong>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>The &lt;code>rc&lt;/code> files are the definitions of your replication controllers, one of them using the version &lt;code>0.1&lt;/code> and the other the image &lt;code>0.2&lt;/code>. The service file is share since the application is going to be the same.&lt;/p>
&lt;p>Let&amp;rsquo;s run the first version of the app:&lt;/p>
&lt;pre>&lt;code>kubectl -f rc-0.1.yml -f service.yml --validate=false
# The validate tag is just needed because of a bug in current k8s
&lt;/code>&lt;/pre>
&lt;p>Now, if you do &lt;code>kubectl get services&lt;/code> you will see the external IP of your service. You can use it to check that it&amp;rsquo;s running and showing the code of the version &lt;code>0.1&lt;/code>.&lt;/p>
&lt;p>Cool! You have deployed your first k8s application, now, let&amp;rsquo;s update it:&lt;/p>
&lt;pre>&lt;code>kubectl rolling-update flaskapp-rc -f rc-0.2.yml
&lt;/code>&lt;/pre>
&lt;p>If you wait a little bit you will see in the logs what&amp;rsquo;s happening there. Let the command finish and you will have your &lt;code>0.2&lt;/code> version deployed having causing 0 downtime!&lt;/p>
&lt;p>As always, feel free to contact me here or use twitter: &lt;a href="https://twitter.com/agonzalezro">@agonzalezro&lt;/a>&lt;/p></description></item></channel></rss>